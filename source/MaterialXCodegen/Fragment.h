//
// TM & (c) 2020 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
// All rights reserved. See LICENSE.txt for license.
//

#ifndef MATERIALX_CODEGEN_FRAGMENT_H
#define MATERIALX_CODEGEN_FRAGMENT_H

/// @file Fragment.h
/// TODO: Docs

#include <MaterialXRuntime/Library.h>
#include <MaterialXRuntime/RtToken.h>
#include <MaterialXRuntime/RtValue.h>

#include <MaterialXCodegen/Syntax.h>

namespace MaterialX
{
namespace Codegen
{

template<class T>
class ObjectList
{
public:
    using ObjectPtr = RtSharedPtr<T>;

    size_t size() const
    {
        return _order.size();
    }

    T* get(const RtToken& name) const
    {
        auto it = _objects.find(name);
        return it != _objects.end() ? it->second.get() : nullptr;
    }

    T* get(size_t index) const
    {
        return index < _order.size() ? _order[index] : nullptr;
    }

    T** order()
    {
        return _order.data();
    }

    const T** order() const
    {
        return _order.data();
    }

    void add(const RtToken& name, const ObjectPtr& obj)
    {
        _objects[name] = obj;
        _order.push_back(obj.get());
    }

    void remove(const RtToken& name)
    {
        auto i = _objects.find(name);
        if (i != _objects.end())
        {
            const T* ptr = i->second.get();
            for (auto j = _order.begin(); j != _order.end(); ++j)
            {
                if ((*j) == ptr)
                {
                    _order.erase(j);
                    break;
                }
            }
            _objects.erase(i);
        }
    }

    void clear()
    {
        _objects.clear();
        _order.clear();
    }

private:
    RtTokenMap<ObjectPtr> _objects;
    vector<T*> _order;
};


/// @class SourceCode
/// Container for source code generated by fragment compilers.
class SourceCode
{
public:
    /// Contructor.
    SourceCode();

    /// Start a new scope using the given bracket type.
    void beginScope(Syntax::Punctuation punc = Syntax::CURLY_BRACKETS);

    /// End the current scope.
    void endScope(bool semicolon = false, bool newline = true);

    /// Start a new line.
    void beginLine();

    /// End the current line.
    void endLine(bool semicolon = true);

    /// Add a newline character.
    void newLine();

    /// Add a generic code string.
    void addString(const string& str);

    /// Add a line of code, optionally appending a semicolon.
    void addLine(const string& str, bool semicolon = true);

    /// Set the given function as defined in this source code.
    void setDefined(const RtToken& function);

    /// Return true if the given function has been defined in this source code.
    bool isDefined(const RtToken& function) const;

    /// Set the given file as included in this source code.
    void setIncluded(const RtToken& file);

    /// Return true if the given file is set as included in this source code.
    bool isIncluded(const RtToken& file) const;

    /// Return the source code.
    const string& asString() const;

    /// Return the source code.
    string& asString();

private:
    int _indentations;
    vector<Syntax::Punctuation> _scopes;
    RtTokenSet _functions;
    RtTokenSet _includes;
    string _code;
};



enum FragmentType
{
    FRAGMENT_TYPE_SOURCE_CODE,
    FRAGMENT_TYPE_GRAPH,
    FRAGMENT_TYPE_BSDF,
    FRAGMENT_TYPE_SHADER,
    FRAGMENT_TYPE_LAST
};

/// Flags for classifying fragments into different categories.
class FragmentClassification
{
public:
    // Node classes
    static const uint32_t TEXTURE = 1 << 0;  /// Any node that outputs floats, colors, vectors, etc.
    static const uint32_t CLOSURE = 1 << 1;  /// Any node that represents light integration
    static const uint32_t SHADER = 1 << 2;  /// Any node that outputs a shader
    // Specific texture node types
    static const uint32_t FILETEXTURE = 1 << 3;  /// A file texture node
    static const uint32_t CONDITIONAL = 1 << 4;  /// A conditional node
    static const uint32_t CONSTANT = 1 << 5;  /// A constant node
    // Specific closure types
    static const uint32_t BSDF = 1 << 6;  /// A BSDF node
    static const uint32_t BSDF_R = 1 << 7;  /// A BSDF node only for reflection
    static const uint32_t BSDF_T = 1 << 8;  /// A BSDF node only for transmission
    static const uint32_t EDF = 1 << 9;  /// A EDF node
    static const uint32_t VDF = 1 << 10; /// A VDF node
    static const uint32_t LAYER = 1 << 11; /// A node for vertical layering of other closure nodes
    static const uint32_t THINFILM = 1 << 12; /// A node for adding thin-film over microfacet BSDF nodes
    // Specific shader types
    static const uint32_t SURFACE = 1 << 13; /// A surface shader node
    static const uint32_t VOLUME = 1 << 14; /// A volume shader node
    static const uint32_t LIGHT = 1 << 15; /// A light shader node
    // Specific conditional types
    static const uint32_t IFELSE = 1 << 16; /// An if-else statement
    static const uint32_t SWITCH = 1 << 17; /// A switch statement
    // Types based on nodegroup
    static const uint32_t SAMPLE2D = 1 << 18; /// Can be sampled in 2D (uv space)
    static const uint32_t SAMPLE3D = 1 << 19; /// Can be sampled in 3D (position)
};

/// A fragment creator function type.
using FragmentCreatorFunction = std::function<FragmentPtr(const RtToken&)>;

/// @class Fragment
/// Class holding a fragment of code.
class Fragment : public RtSharedBase<Fragment>
{
  public:
    struct Port
    {
        Fragment* parent;
        RtToken type;
        RtToken name;
        RtToken variable;

        string getLongName() const
        {
            return parent->getName().str() + "_" + name.str();
        }
    };

    struct Output;

    struct Input : public Port
    {
        RtValue value;
        Output* connection;
    };

    struct Output : public Port
    {
        std::set<Input*> connections;
    };

    using OutputPtr = RtSharedPtr<Output>;
    using InputPtr = RtSharedPtr<Input>;

  public:
    /// Constructor.
    Fragment(const RtToken& name);

    /// Destructor.
    virtual ~Fragment() {}

    /// Return the fragment type.
    virtual FragmentType getType() const = 0;

    /// Return the fragment class name.
    virtual const RtToken& getClassName() const = 0;

    /// Return the name of the fragment instance.
    const RtToken& getName() const
    {
        return _name;
    }

    bool hasClassification(uint32_t mask) const
    {
        return (_classification & mask) != 0;
    }

    void setClassification(uint32_t mask, bool value = true)
    {
        _classification = value ? _classification | mask : _classification & ~mask;
    }

    uint32_t getClassificationMask() const
    {
        return _classification;
    }

    template<class T>
    T* asA()
    {
        return static_cast<T*>(this);
    }

    template<class T>
    const T* asA() const
    {
        return static_cast<T*>(this);
    }

    virtual Input* createInput(const RtToken& type, const RtToken& name);

    virtual Output* createOutput(const RtToken& type, const RtToken& name);

    size_t numInputs() const
    {
        return _inputs.size();
    }
    
    Input* getInput(size_t index) const
    {
        return _inputs.get(index);
    }

    Input* getInput(const RtToken& name) const
    {
        return _inputs.get(name);
    }

    size_t numOutputs() const
    {
        return _outputs.size();
    }

    Output* getOutput(size_t index = 0) const
    {
        return _outputs.get(index);
    }

    Output* getOutput(const RtToken& name) const
    {
        return _outputs.get(name);
    }

    /// Set fragment function name.
    void setFunctionName(const RtToken& functionName)
    {
        _functionName = functionName;
    }

    /// Return fragment function name.
    const RtToken& getFunctionName() const
    {
        return _functionName;
    }

    virtual void emitFunctionDefinitions(const Context& context, SourceCode& result) const = 0;

    virtual void emitFunctionCall(const Context& context, SourceCode& result) const = 0;

  protected:
    /// Fragment name.
    const RtToken _name;

    /// Fragment classification mask.
    uint32_t _classification;

    /// Fragment function name.
    RtToken _functionName;

    /// Allocator for large values.
    RtAllocator _allocator;

    /// Fragment ports.
    ObjectList<Input> _inputs;
    ObjectList<Output> _outputs;
};

/// @class FragmentGraph
/// Class holding a set of fragments connected in a graph.
class FragmentGraph : public Fragment
{
public:
    /// Constructor.
    FragmentGraph(const RtToken& name);

    /// Create a new instance of this class.
    static FragmentPtr create(const RtToken& name);

    /// Return the class name for this fragment.
    static const RtToken& className();

    /// Return the fragment type.
    FragmentType getType() const override
    {
        return FRAGMENT_TYPE_GRAPH;
    }

    /// Return the fragment class name.
    const RtToken& getClassName() const override
    {
        return className();
    }

    /// Add a fragment to the graph.
    void addFragment(const FragmentPtr& fragment);

    /// Remove a fragment from the results.
    void removeFragment(const RtToken& name);

    /// Return the number of fragments contained in this graph.
    size_t numFragments() const;

    /// Return a fragment by index.
    Fragment* getFragment(size_t index) const;

    /// Return a fragment by name.
    Fragment* getFragment(const RtToken& name) const;

    /// Create a connections between two fragments.
    void connect(Fragment::Output* src, Fragment::Input* dst);

    /// Create a connections between two fragments.
    void connect(const RtToken& srcFragment, const RtToken& srcOutput,
                 const RtToken& dstFragment, const RtToken& dstOutput);

    Input* createInput(const RtToken& type, const RtToken& name) override;

    Output* createOutput(const RtToken& type, const RtToken& name) override;

    Output* getInputSocket(size_t index) const
    {
        return _inputSockets.get(index);
    }

    Output* getInputSocket(const RtToken& name) const
    {
        return _inputSockets.get(name);
    }

    Input* getOutputSocket(size_t index = 0) const
    {
        return _outputSockets.get(index);
    }

    Input* getOutputSocket(const RtToken& name) const
    {
        return _outputSockets.get(name);
    }

    /// Finalize the graph construction.
    void finalize(const Context& context, bool publishAllInputs = false);

    void emitFunctionDefinitions(const Context& context, SourceCode& result) const override;

    void emitFunctionCall(const Context& context, SourceCode& result) const override;

protected:
    ObjectList<Fragment> _fragments;
    ObjectList<Output> _inputSockets;
    ObjectList<Input> _outputSockets;
};

/// @class SourceFragment
/// Class holding a fragment of static source code.
class SourceFragment : public Fragment
{
public:
    /// Constructor.
    SourceFragment(const RtToken& name);

    /// Create a new instance of this class.
    static FragmentPtr create(const RtToken& name);

    /// Return the class name for this fragment.
    static const RtToken& className();

    /// Return the fragment type.
    FragmentType getType() const override
    {
        return FRAGMENT_TYPE_SOURCE_CODE;
    }

    /// Return the fragment class name.
    const RtToken& getClassName() const override
    {
        return className();
    }

    /// Set fragment source code.
    void setSourceCode(const string* sourceCode)
    {
        _sourceCode = sourceCode;
    }

    bool isInline() const
    {
        return _functionName == EMPTY_TOKEN;
    }

    void emitFunctionDefinitions(const Context& context, SourceCode& result) const override;

    void emitFunctionCall(const Context& context, SourceCode& result) const override;

protected:
    /// Source code for this fragment.
    const string* _sourceCode;
};

} // namespace Codegen
} // namespace MaterialX

#endif
